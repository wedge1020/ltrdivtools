#!/usr/bin/env bash
### 
### relationalchains - a script to generate initial relational chains content for
###                    a puzzle solving experience, and if chains exist,  to show
###                    them. The script will also manage adding new clues and the
###                    construction of compound chains.
### 
###        usage: relationalchains [OPTION..] PUZZLE
###               relationalchains [OPTION..] < PUZZLE
###               relationalchains add "X << Y" PUZZLE
###    
###      option - description 
###     =======   ====================================================================
###         add - incorporate a new relational clue into the database (takes string)
###        join - concatenate common elements of rules together
###      remove - remove a relational clue from the database (takes string)
###     nolabel - do not display content label
###       debug - enable bash debugging
###     verbose - display variable information during runtime
###        help - display this usage information and exit
### 
### NOTE: labels are on by default, and the LABEL environment variable can influence
###       this behaviour (set to "true" or "false")
### 
########################################################################################

########################################################################################
##
## Declare variables
##
declare -A clues
PZLTMP=$(mktemp -p /tmp relationalchains.XXXX)
REGEX='\<(join|nolabel|verbose|debug|help)\>'

########################################################################################
##
## Parameter processing
##
DOJOIN=$(echo  "${*}"    | egrep -qio '\<join\>'    && echo "true"  || echo "false")
DOLABEL=$(echo "${*}"    | egrep -qio '\<nolabel\>' && echo "false" || echo "true")
DEBUG=$(echo   "${*}"    | egrep -qio '\<debug\>'   && echo "true"  || echo "false")
VERBOSE=$(echo "${*}"    | egrep -qio '\<verbose\>' && echo "true"  || echo "false")
DOHELP=$(echo  "${*}"    | egrep -qio '\<help\>'    && echo "true"  || echo "false")
ARGS=$(echo    "${*}"    | tr ' ' '\n' | egrep -v "${REGEX}" | tr '\n' ' ')
ARGS=$(echo    "${ARGS}" | grep -v '^[ ]*$')
[ "${LABEL}" = "false" ] && DOLABEL="false"

########################################################################################
##
## ADD: Parse available clues, massage into consistent format
##
#echo "ARGS: ${ARGS}"
CLUERGX='[A-Za-z0-9] \?[<>][<>]\? \?[A-Za-z0-9]'
ADD=$(echo     "${ARGS}" | grep -io "\<add ${CLUERGX}\>")
ADD=$(echo     "${ADD}"  | sed 's/[Aa][Dd][Dd] //g')
ADD=$(echo     "${ADD}"  | sed 's/\([A-Za-z0-9]\) =/\1=/g')
ADD=$(echo     "${ADD}"  | sed 's/= \([A-Za-z0-9]\)/=\1/g')
ADD=$(echo     "${ADD}"  | sed 's/\([A-Za-z0-9]\) </\1</g')
ADD=$(echo     "${ADD}"  | sed 's/< \([A-Za-z0-9]\)/<\1/g')
ADD=$(echo     "${ADD}"  | sed 's/\([A-Za-z0-9]\) \?> \?\([A-Za-z0-9]\)/\2<\1/g')
ADD=$(echo     "${ADD}"  | sed 's/\([A-Za-z0-9]\) \?>> \?\([A-Za-z0-9]\)/\2<<\1/g')
#echo "ADD: ${ADD}"
for clue in ${ADD}; do
    echo "${clue}"
done                                                                  >  pzl.clues

########################################################################################
##
## JOIN: Parse given clues, process into consistent format
##
function one_less_than()
{
    NEW_MD5=$(cat pzl.clues | md5sum | cut -d' ' -f1)
    OLD_MD5=0
    while [ ! "${NEW_MD5}" = "${OLD_MD5}" ]; do
        CLUE_LIST=$(cat pzl.clues | grep -o '[^<]<[^<]')
        for clue in ${CLUE_LIST}; do
            left=$(echo  "${clue}" | cut -d'<' -f1)
            right=$(echo "${clue}" | cut -d'<' -f2)
            SEDEXP="/${clue}/!s/${left}/${clue}/g"
            cat pzl.clues     | grep -v "^${clue}$" | sed "${SEDEXP}" >  pzl.clues.tmp
            SEDEXP="/${clue}/!s/${right}/${clue}/g"
            cat pzl.clues.tmp | grep -v "^${clue}$" | sed "${SEDEXP}" >  pzl.clues
            cchk=$(cat pzl.clues | grep "${clue}" | wc -l)
            [ "${cchk}" -eq 0 ] && echo "${clue}"                     >> pzl.clues
            cat pzl.clues | sort | uniq                               >  pzl.clues.tmp
            CLUE_LIST="${CLUE_LIST} $(cat pzl.clues.tmp | grep -o '[^<]<[^<]')"
            CLUE_LIST=$(echo "${CLUE_LIST}" | tr ' ' '\n' | sort | uniq)
        done
        cat pzl.clues.tmp                                             >  pzl.clues
        OLD_MD5="${NEW_MD5}"
        NEW_MD5=$(cat pzl.clues | md5sum | cut -d' ' -f1)
    done
}

function somewhat_less_than()
{
    NEW_MD5=$(cat pzl.clues | md5sum | cut -d' ' -f1)
    OLD_MD5=0
    while [ ! "${NEW_MD5}" = "${OLD_MD5}" ]; do
        CLUE_LIST=$(cat pzl.clues | egrep -o '[^<]<<[^<](<[^<])*')
        for clue in ${CLUE_LIST}; do
            left=$(echo  "${clue}" | sed 's/<</:/g' | cut -d':' -f1)
            right=$(echo "${clue}" | sed 's/<</:/g' | cut -d':' -f2)
            SEDEXP="/${clue}/!s/${left}$/${clue}/g"
            cat pzl.clues     | grep -v "^${clue}$" | sed "${SEDEXP}" >  pzl.clues.tmp
            SEDEXP="/${clue}/!s/^${right}/${clue}/g"
            cat pzl.clues.tmp | grep -v "^${clue}$" | sed "${SEDEXP}" >  pzl.clues
            cchk=$(cat pzl.clues | grep "${clue}" | wc -l)
            [ "${cchk}" -eq 0 ] && echo "${clue}"                     >> pzl.clues
            cat pzl.clues | sort | uniq                               >  pzl.clues.tmp
            CLUE_LIST="${CLUE_LIST} $(cat pzl.clues.tmp | egrep -o '[^<]<<[^<](<[^<])*')"
            CLUE_LIST=$(echo "${CLUE_LIST}" | tr ' ' '\n' | sort | uniq)
        done
        cat pzl.clues.tmp                                             >  pzl.clues
        OLD_MD5="${NEW_MD5}"
        NEW_MD5=$(cat pzl.clues | md5sum | cut -d' ' -f1)
    done
}

function eliminate_redundant_fragments()
{
    CLUE_LIST=$(cat pzl.clues)
    for clue in ${CLUE_LIST}; do
        rchk=$(cat pzl.clues | grep -v "^${clue}$" | grep "${clue}" | wc -l)
        if [ "${rchk}" -gt 0 ]; then
            cat pzl.clues | grep -v "^${clue}$"                       >  pzl.clues.tmp
            cat pzl.clues.tmp                                         >  pzl.clues
        fi
    done
}

#CLUERGX='[A-Za-z0-9] \?[<>][<>]\? \?[A-Za-z0-9]'
#JOIN=$(echo    "${ARGS}" | grep -io "\<join ${CLUERGX} ${CLUERGX}\>")
#JOIN=$(echo    "${JOIN}" | sed 's/[Jj][Oo][Ii][Nn] //g')
#JOIN=$(echo    "${JOIN}" | sed 's/\([A-Za-z0-9]\) =/\1=/g')
#JOIN=$(echo    "${JOIN}" | sed 's/= \([A-Za-z0-9]\)/=\1/g')
#JOIN=$(echo    "${JOIN}" | sed 's/\([A-Za-z0-9]\) </\1</g')
#JOIN=$(echo    "${JOIN}" | sed 's/< \([A-Za-z0-9]\)/<\1/g')
#JOIN=$(echo    "${JOIN}" | sed 's/\([A-Za-z0-9]\) \?> \?\([A-Za-z0-9]\)/\2<\1/g')
#JOIN=$(echo    "${JOIN}" | sed 's/\([A-Za-z0-9]\) \?>> \?\([A-Za-z0-9]\)/\2<<\1/g')
#
#for item in ${JOIN}; do
#    clue1=$(echo      "${item}"  | cut -d' ' -f1)
#    clue1left=$(echo  "${clue1}" | cut -d'<' -f1)
#    clue1right=$(echo "${clue1}" | cut -d'<' -f2)
#    clue2=$(echo      "${item}"  | cut -d' ' -f2)
#    clue2left=$(echo  "${clue2}" | cut -d'<' -f1)
#    clue2right=$(echo "${clue2}" | cut -d'<' -f2)
#    cat pzl.clues | egrep -vi "^(${clue1}|${clue2})$"                 >  pzl.clues.tmp
#    echo "join: ${item}"
#done
#exit

if [ "${DOJOIN}" = "true" ]; then

	echo "exactly one less than"
    one_less_than
	echo "somewhat less than"
    somewhat_less_than
	echo "exactly one less than"
    one_less_than
	echo "somewhat less than"
    somewhat_less_than
	echo "eliminate redundant fragments"
	eliminate_redundant_fragments
	echo "resulting clueset:"
    cat pzl.clues
    exit
    rm -f pzl.clues pzl.clues.tmp

fi
#    for ((index=0; index<2; index++)); do
#        CLUE_LIST=$(cat pzl.clues | egrep -o '[^<]<<[^<]')
#        #CLUE_LIST=$(cat pzl.clues | egrep -o '[^<]<<([^<]|([^<]<)*)')
#        for clue in ${CLUE_LIST}; do
#            left=$(echo  "${clue}" | sed 's/<</:/g' | cut -d':' -f1)
#            right=$(echo "${clue}" | sed 's/<</:/g' | cut -d':' -f2)
#            echo "clue: ${clue}"
#            SEDEXP="/${clue}/!s/${left}/${clue}/g"
#            cat pzl.clues     | grep -v "^${clue}$" | sed "${SEDEXP}" >  pzl.clues.tmp
#            SEDEXP="/${clue}/!s/${right}/${clue}/g"
#            cat pzl.clues.tmp | grep -v "^${clue}$" | sed "${SEDEXP}" >  pzl.clues
#            cchk=$(cat pzl.clues | grep "${clue}" | wc -l)
#            [ "${cchk}" -eq 0 ] && echo "${clue}"                     >> pzl.clues
#            cat pzl.clues | sort | uniq                               >  pzl.clues.tmp
#            cat pzl.clues.tmp
#            CLUE_LIST="${CLUE_LIST} $(cat pzl.clues.tmp | grep -o '[^<]<[^<]')"
#            CLUE_LIST=$(echo "${CLUE_LIST}" | tr ' ' '\n' | sort | uniq)
#            echo "----"
#        done
#        cat pzl.clues.tmp                                             >  pzl.clues
#    done

########################################################################################
##
## Be verbose, if enabled
##
if [ "${VERBOSE}" = "true" ]; then
    echo "[verbose] VERBOSE: ${VERBOSE}"
    echo "[verbose] PZLTMP:  ${PZLTMP}"
    echo "[verbose] ARGS:    ${ARGS}"
    echo "[verbose] DOLABEL: ${DOLABEL}"
    echo "[verbose] DEBUG:   ${DEBUG}"
    echo "[verbose] DOHELP:  ${DOHELP}"
fi

########################################################################################
##
## Transact argument functionality
##
[ "${DEBUG}"  = "true" ] && set -x
[ "${DOHELP}" = "true" ] && cat ${0} | grep '^### ' | sed 's/### //g' && exit 0

########################################################################################
##
## Check for STDIN redirection
##
if [ -z "${ARGS}" ]; then
    cat                                                               >  ${PZLTMP}
    PZLFILE="${PZLTMP}"
    cat ${PZLFILE}
    echo
else
    PZLFILE=$(echo "${ARGS}" | tr -d ' ')
fi
[ "${VERBOSE}" = "true" ] && echo "[verbose] PZLFILE: ${PZLFILE}"
[ ! -r "${PZLFILE}"     ] && echo "ERROR: could not read ${PZLFILE}" && exit 1

########################################################################################
##
## Display the results to STDOUT
##
[ "${DOLABEL}" = "true" ] && echo "Relational Chains:" && echo && echo "  * " && echo

########################################################################################
##
## Remove temporary files
##
rm -f ${PZLTMP}

exit 0
