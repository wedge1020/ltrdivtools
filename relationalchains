#!/usr/bin/env bash
### 
### relationalchains - a script to generate initial relational chains content for
###                    a puzzle solving experience, and if chains exist,  to show
###                    them. The script will also manage adding new clues and the
###                    construction of compound chains.
### 
###        usage: relationalchains [OPTION..] PUZZLE
###               relationalchains [OPTION..] < PUZZLE
###               relationalchains add "X << Y" PUZZLE
###    
###      option - description 
###     =======   ====================================================================
###         add - incorporate a new relational clue into the database (takes string)
###      remove - remove a relational clue from the database (takes string)
###     nolabel - do not display content label
###       debug - enable bash debugging
###     verbose - display variable information during runtime
###        help - display this usage information and exit
### 
### NOTE: labels are on by default, and the LABEL environment variable can influence
###       this behaviour (set to "true" or "false")
### 
########################################################################################

########################################################################################
##
## Declare variables
##
declare -A clues
PZLTMP=$(mktemp -p /tmp relationalchains.XXXX)
REGEX='\<(nolabel|verbose|debug|help)\>'

########################################################################################
##
## Parameter processing
##
DOLABEL=$(echo "${*}"    | egrep -qio '\<nolabel\>' && echo "false" || echo "true")
DEBUG=$(echo   "${*}"    | egrep -qio '\<debug\>'   && echo "true"  || echo "false")
VERBOSE=$(echo "${*}"    | egrep -qio '\<verbose\>' && echo "true"  || echo "false")
DOHELP=$(echo  "${*}"    | egrep -qio '\<help\>'    && echo "true"  || echo "false")
ARGS=$(echo    "${*}"    | tr ' ' '\n' | egrep -v "${REGEX}" | tr '\n' ' ')
ARGS=$(echo    "${ARGS}" | grep -v '^[ ]*$')
[ "${LABEL}" = "false" ] && DOLABEL="false"

########################################################################################
##
## Parse available clues, massage into consistent format
##
#echo "ARGS: ${ARGS}"
ADD=$(echo     "${ARGS}" | grep -io '\<add [A-Za-z0-9] \?[<>=][<>]\? \?[A-Za-z0-9]\>')
ADD=$(echo     "${ADD}"  | sed 's/add //g')
ADD=$(echo     "${ADD}"  | sed 's/\([A-Za-z0-9]\) =/\1=/g')
ADD=$(echo     "${ADD}"  | sed 's/= \([A-Za-z0-9]\)/=\1/g')
ADD=$(echo     "${ADD}"  | sed 's/\([A-Za-z0-9]\) </\1</g')
ADD=$(echo     "${ADD}"  | sed 's/< \([A-Za-z0-9]\)/<\1/g')
ADD=$(echo     "${ADD}"  | sed 's/\([A-Za-z0-9]\) \?> \?\([A-Za-z0-9]\)/\2<\1/g')
ADD=$(echo     "${ADD}"  | sed 's/\([A-Za-z0-9]\) \?>> \?\([A-Za-z0-9]\)/\2<<\1/g')
#echo "ADD: ${ADD}"
for clue in ${ADD}; do
	echo "${clue}"
done                                                                     >  pzl.clues

CLUE_LIST=$(cat pzl.clues | grep '[^<]<[^<]')
for clue in ${CLUE_LIST}; do
	left=$(echo  "${clue}" | cut -d'<' -f1)
	right=$(echo "${clue}" | cut -d'<' -f2)
	echo "clue: ${clue}"
	cat pzl.clues     | grep -v "^${clue}$" | sed "/${clue}/!s/${left}/${clue}/g"  >  pzl.clues.tmp
	cat pzl.clues.tmp | grep -v "^${clue}$" | sed "/${clue}/!s/${right}/${clue}/g" >  pzl.clues
	cchk=$(cat pzl.clues | grep "${clue}" | wc -l)
	[ "${cchk}" -eq 0 ] && echo "${clue}"                                >> pzl.clues
	cat pzl.clues | sort | uniq                                          >  pzl.clues.tmp
	cat pzl.clues.tmp
	echo "----"
done
rm -f pzl.clues pzl.clues.tmp pzl.clues.tmp2
exit

########################################################################################
##
## Be verbose, if enabled
##
if [ "${VERBOSE}" = "true" ]; then
    echo "[verbose] VERBOSE: ${VERBOSE}"
    echo "[verbose] PZLTMP:  ${PZLTMP}"
    echo "[verbose] ARGS:    ${ARGS}"
    echo "[verbose] DOLABEL: ${DOLABEL}"
    echo "[verbose] DEBUG:   ${DEBUG}"
    echo "[verbose] DOHELP:  ${DOHELP}"
fi

########################################################################################
##
## Transact argument functionality
##
[ "${DEBUG}"  = "true" ] && set -x
[ "${DOHELP}" = "true" ] && cat ${0} | grep '^### ' | sed 's/### //g' && exit 0

########################################################################################
##
## Check for STDIN redirection
##
if [ -z "${ARGS}" ]; then
    cat                                                                  >  ${PZLTMP}
    PZLFILE="${PZLTMP}"
    cat ${PZLFILE}
    echo
else
    PZLFILE=$(echo "${ARGS}" | tr -d ' ')
fi
[ "${VERBOSE}" = "true" ] && echo "[verbose] PZLFILE: ${PZLFILE}"
[ ! -r "${PZLFILE}"     ] && echo "ERROR: could not read ${PZLFILE}" && exit 1

########################################################################################
##
## Display the results to STDOUT
##
[ "${DOLABEL}" = "true" ] && echo "Relational Chains:" && echo && echo "  * " && echo

########################################################################################
##
## Remove temporary files
##
rm -f ${PZLTMP}

exit 0
